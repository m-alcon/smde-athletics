plot(input,target, lwd=3, ylim = c(-1.1, 1.1))                # dades de TR
curve (sin(2*pi*x), a, b, add=TRUE, ylim = c(-1.1, 1.1))      # part regular a modelar
points(input, predict(model), type="l", col="red", lwd=2)     # el model obtingut
(NMSE <- model$deviance/((N-1)*var(target)))
plot(valid.sample$input, valid.sample$target)
prediccions <- predict (model, newdata=valid.sample)
(NMSE.valid <- sum((valid.sample$target - prediccions)^2)/((N.valid-1)*var(valid.sample$target)))
p <- 1
q <- N-1
coef <- list()
model <- list()
norm.mse.train <- NULL
norm.mse.valid <- NULL
for (i in p:q)
{
model[[i]] <- glm(target ~ poly(input, i, raw=TRUE), data = sample, family = gaussian)
# desem coeficients del polinomi (del model) i els error de training i validacio
coef[[i]] <- model[[i]]$coefficients
norm.mse.train[i] <- model[[i]]$deviance/((N-1)*var(target))
prediccions <- predict (model[[i]], newdata=valid.sample)
norm.mse.valid[i] <- sum((valid.sample$target - prediccions)^2)/((N.valid-1)*var(valid.sample$target))
}
resultats <- cbind (Grau=p:q, Coeficients=coef, Error.train=norm.mse.train, Error.valid=norm.mse.valid)
par(mfrow=c(2, 3))                # això crea una graella (grid) de 2x3
graus <- c(1,2,3,4,9,19)
for (i in graus)
{
plot(input,target, lwd=3)
curve (sin(2*pi*x), a, b, add=TRUE)
abline(0,0)
points(input, predict(model[[i]]), type="l", col=25+i, lwd=2)
title (main=paste('Grau',i))
}
for (i in graus)
{
plot(valid.sample$input, valid.sample$target)
curve (sin(2*pi*x), a, b, add=TRUE, col='yellow',lwd=2)
points(valid.sample$input, predict(model[[i]], newdata=valid.sample), type="l", col=25+i, lwd=2)
title (main=paste('Grau',i))
}
(r <- data.frame(resultats[,-2]))
par(mfrow=c(1,1))
plot(1:20, 1:20, xlim=c(1,16), ylim=c(0,1.5), type = "n", xlab="Grau", ylab="", xaxt="n")
axis(1, at=1:16,labels=1:16, col.axis="red", las=2)
points (x=r$Grau[1:16], y=r$Error.train[1:16], type='b', pch=0)
points (x=r$Grau[1:16], y=r$Error.valid[1:16], type='b', pch=3, lwd=3)
legend(x="topleft", legend=c("Error.TR", "Error.VA"), pch=c(0, 3), lwd=c(1, 3))
coefs.table <- matrix (nrow=10, ncol=9)
for (i in 1:10)
for (j in 1:9)
coefs.table[i,j] <- coef[[j]][i]
coefs.table
coefs.table
N.big <- 100                       # abans eren 20, la resta és exactament igual
x <- seq(a,b,length.out=N.big)
t <- sin(2*pi*x) + rnorm(N.big, mean=0, sd=sqrt(sigma.quadrat))
big.sample <- data.frame(input=x,target=t)
attach(big.sample)
par(mfrow=c(1, 1))
plot(big.sample$input,big.sample$target, lwd=3)
model <- glm(target ~ poly(input, 9, raw=TRUE), data = big.sample, family = gaussian)
nmse.train <- model$deviance/((N.big-1)*var(target))
prediccions <- predict (model, newdata=valid.sample)
nmse.valid <- sum((valid.sample$target - prediccions)^2)/((N.big-1)*var(valid.sample$target))
curve (sin(2*pi*x), a, b, add=TRUE)
points(big.sample$input, predict(model), type="l", col="red", lwd=2)
library(MASS)
par(mfcol=c(1,1))
lambdes <- seq(0.001,0.5,0.001)
length(lambdes)
model <- glm (target ~ poly(input, 12, raw=TRUE), data = sample, family = gaussian)
model.ridge <- lm.ridge (model, lambda = lambdes)
plot(model.ridge, lty=1:3)
select( lm.ridge(model, lambda = lambdes) )
model.final <- lm.ridge (model,lambda=0.008)
coef(model)         # M=12 (estàndar)
coef(model.final)   # M=12 (regularitzat)
sqrt(sum(coef(model)^2)) / sqrt(sum(coef(model.final)^2))
plot (log10(abs(coef(model) / coef(model.final))), xlim=c(1,13), xlab="Grau", ylab="", main="Log10 quocient", type="b")
prediccions.classic <- predict (model, newdata=valid.sample)
(NMSE.VA.classic <- sum((valid.sample$target - prediccions.classic)^2)/((N.valid-1)*var(valid.sample$target)))
(c <- setNames(coef(model.final), paste0("c_", 0:12)))
pots <- outer (X=valid.sample$input, Y=0:12, FUN="^")
prediccions.regul <- pots %*% c
(NMSE.VA.regul <- sum((valid.sample$target - prediccions.regul)^2)/((N.valid-1)*var(valid.sample$target)))
(X <- matrix(data=c(1,2,3,3,3,5,5,4,5,6,6,5,8,7,9,8),nrow=8,ncol=2,byrow=TRUE))
cov(X)
eigen (X, only.values=TRUE)$values
eigen (CV, only.values=TRUE)$values
CV <- cov(X)
eigen (CV, only.values=TRUE)$values
eigen (CV, only.values=TRUE)
(X <- matrix(data=c(1,2,3,3,3,5,5,4,5,6,6,5,8,7,9,8),nrow=8,ncol=2,byrow=TRUE))
CV <- cov(X)
eigen (CV, only.values=TRUE)
eigen (CV)
plot(X)
set.seed(222)
library(MASS)
N <- 200
(Sigma <- matrix(data=c(2,1.3,1.3,1),nrow=2,ncol=2,byrow=TRUE))
eigen (Sigma, only.values=TRUE)$values
mean.1 <- matrix(c(2,0),nrow=2,ncol=1)
X.red <- mvrnorm(N,mu=mean.1,Sigma=Sigma)
mean.2 <- -mean.1
X.green <- mvrnorm(N,mu=mean.2,Sigma=Sigma)
par(mfrow=c(2,2))
plot(c(X.red[,1],X.green[,1]), c(X.red[,2],X.green[,2]),
xlim=c(-6,6),ylim=c(-6,6),
col=c(rep('red',N),rep('green',N)), main="Toy data", xlab="X1", ylab="X2")
d <- data.frame(c(rep(1,N),rep(2,N)), c(X.red[,1], X.green[,1]), c(X.red[,2], X.green[,2]))
colnames(d) <- c("target", "X1", "X2")
d$target <- as.factor(d$target)
summary(d)
myLDA <- lda(d[c(2,3)],d[,1])
LDAslope <- myLDA$scaling[2]/myLDA$scaling[1]
plot(c(X.red[,1],X.green[,1]), c(X.red[,2],X.green[,2]), col=c(rep('red',N),rep('green',N)),
xlim=c(-6,6),ylim=c(-6,6),
main="Direction for projection using FDA", xlab="X1", ylab="X2")
abline(0,LDAslope,col='black',lwd=2)
myLDA.proj <- d[,2] * myLDA$scaling[1] + d[,3] * myLDA$scaling[2]
plot(myLDA.proj, c(rep(0,N),rep(0,N)), col=c(rep('green',N),rep('red',N)),
main='FDA projection as seen in 1D', xlab="Discriminant", ylab="")
myLDA
myLDA$scaling
myPCA <- prcomp(d[c(2,3)],scale=TRUE)
d1PCA <- myPCA$x[,1]
PCAslope1 <- myPCA$rotation[2,1]/myPCA$rotation[1,1]
plot(c(X.red[,1],X.green[,1]), c(X.red[,2],X.green[,2]), col=c(rep('red',N),rep('green',N)),
xlim=c(-6,6),ylim=c(-6,6),
main="Direction for projection using PCA", xlab="X1", ylab="X2")
abline(0,PCAslope1,col='black',lwd=2)
(X <- matrix(data=c(1,2,3,3,3,5,5,4,5,6,6,5,8,7,9,8),nrow=8,ncol=2,byrow=TRUE))
CV <- cov(X)
eigen (CV)
plot(X)
myPCA <- prcomp(X,scale=TRUE)
d1PCA <- myPCA$x[,1]
PCAslope1 <- myPCA$rotation[2,1]/myPCA$rotation[1,1]
abline(0,PCAslope1,col='black',lwd=2)
r.restart
rm(list = ls())
graphics.off
(X <- matrix(data=c(1,2,3,3,3,5,5,4,5,6,6,5,8,7,9,8),nrow=8,ncol=2,byrow=TRUE))
CV <- cov(X)
eigen (CV)
plot(X)
myPCA <- prcomp(X,scale=TRUE)
d1PCA <- myPCA$x[,1]
PCAslope1 <- myPCA$rotation[2,1]/myPCA$rotation[1,1]
abline(0,PCAslope1,col='black',lwd=2)
d2PCA <- myPCA$x[,2]
PCAslope2 <- myPCA$rotation[2,1]/myPCA$rotation[1,1]
abline(0,PCAslope2,col='black',lwd=2)
d2PCA <- myPCA$x[,2]
PCAslope2 <- myPCA$rotation[2,2]/myPCA$rotation[1,2]
abline(0,PCAslope2,col='black',lwd=2)
d2PCA <- myPCA$x[,1]
PCAslope2 <- myPCA$rotation[2,2]/myPCA$rotation[1,2]
abline(0,PCAslope2,col='black',lwd=2)
d2PCA <- myPCA$x[,1]
PCAslope2 <- myPCA$rotation[1,1]/myPCA$rotation[2,1]
abline(0,PCAslope2,col='black',lwd=2)
d2PCA <- myPCA$x[,2]
PCAslope2 <- myPCA$rotation[1,1]/myPCA$rotation[2,1]
abline(0,PCAslope2,col='black',lwd=2)
d1PCA
d2PCA
myPCA$rotation
(X <- matrix(data=c(1,2,3,3,3,5,5,4,5,6,6,5,8,7,9,8),nrow=8,ncol=2,byrow=TRUE))
CV <- cov(X)
eigen (CV)
plot(X)
myPCA <- prcomp(X,scale=TRUE)
PCAslope1 <- myPCA$rotation[2,1]/myPCA$rotation[1,1]
abline(0,PCAslope1,col='black',lwd=2)
PCAslope2 <- myPCA$rotation[2,2]/myPCA$rotation[1,2]
abline(0,PCAslope2,col='black',lwd=2)
PCAslope2 <- myPCA$rotation[2,2]/myPCA$rotation[1,2]
abline(0,PCAslope2,col='black',lwd=2)
PCAslope2
abline(1,PCAslope2,col='black',lwd=2)
abline(10,PCAslope2,col='black',lwd=2)
x<-[63,67,63,72,58,61,67,68,68,53]
x<-(63,67,63,72,58,61,67,68,68,53)
x<-{63,67,63,72,58,61,67,68,68,53}
x<-vector(63,67,63,72,58,61,67,68,68,53)
x<-c(63,67,63,72,58,61,67,68,68,53)
x
hist(x)
barplot(x)
mean(x)
x<-c(9, 3, 5, 4, 3, 4, 2, 2, 9, 4, 8, 5, 3, 4, 2, 3, 9, 6, 3, 2, 5, 5, 6, 2, 9, 6, 2, 4, 3, 5, 1, 5, 9, 7, 3, 5, 6, 4, 4, 1, 9, 7, 6, 3, 3, 6, 5, 4, 9, 2, 3, 5, 5, 3, 5, 2, 9, 6, 7, 5, 5, 3, 3, 0, 9, 4, 4, 6, 4, 4, 3, 2, 9, 3, 4, 7, 4, 2, 5, 5, 9, 2, 4, 4, 4, 5, 3, 3, 9, 4, 4, 6, 2, 4, 3, 1, 9, 6, 5, 4, 6, 4, 2, 3, 9, 7, 3, 3, 3, 2, 6, 3, 9, 2, 2, 4, 4, 2, 4, 2, 9, 4, 3, 3, 3, 4, 6, 4])
x<-c(9, 3, 5, 4, 3, 4, 2, 2, 9, 4, 8, 5, 3, 4, 2, 3, 9, 6, 3, 2, 5, 5, 6, 2, 9, 6, 2, 4, 3, 5, 1, 5, 9, 7, 3, 5, 6, 4, 4, 1, 9, 7, 6, 3, 3, 6, 5, 4, 9, 2, 3, 5, 5, 3, 5, 2, 9, 6, 7, 5, 5, 3, 3, 0, 9, 4, 4, 6, 4, 4, 3, 2, 9, 3, 4, 7, 4, 2, 5, 5, 9, 2, 4, 4, 4, 5, 3, 3, 9, 4, 4, 6, 2, 4, 3, 1, 9, 6, 5, 4, 6, 4, 2, 3, 9, 7, 3, 3, 3, 2, 6, 3, 9, 2, 2, 4, 4, 2, 4, 2, 9, 4, 3, 3, 3, 4, 6, 4)
barplot(x)
b<-c(67,67,71,67,58,66,67,57,63,62)
barplot(b)
x<-c(10, 6, 7, 3, 7, 5, 4, 5, 10, 6, 2, 3, 3, 4, 2, 1, 10, 4, 6, 3, 9, 4, 6, 3, 10, 3, 6, 6, 5, 5, 2, 3, 10, 3, 8, 6, 5, 6, 6, 3, 10, 7, 4, 6, 4, 7, 2, 2, 10, 3, 7, 5, 4, 5, 6, 3, 10, 3, 6, 6, 10, 5, 5, 2, 10, 6, 6, 5, 3, 3, 2, 1, 10, 4, 3, 5, 1, 2, 5, 1, 10, 2, 2, 6, 7, 8, 4, 2, 10, 8, 3, 2, 5, 6, 7, 1, 10, 8, 6, 5, 4, 2, 5, 5, 10, 7, 7, 3, 5, 2, 2, 2, 9, 3, 1, 3, 3, 8, 3, 2, 10, 5, 7, 2, 3, 7, 1, 4)
barplot(x)
i <- sqrt(as.complex(-1))
(A <- matrix(c(0,i,0,1),nrow=2,byrow = TRUE))
(A %*% t(A))  # A·A^T és la matriu (-1 i; i 1)
(t(A) %*% A)  # A^T·A és la matriu tot zeros
N <- 10
(X <- matrix(c(rep(1,N), seq(N)),nrow=N))
t <- seq(10,20,length.out=N) + rnorm(N)
plot(X[,2],t,lwd=3)
f<-c(1,2,3,4,5)
l<-c(7.97,10.2,14.2,16.0,21.2)
plot(f,l)
N <- 10
(X <- matrix(c(rep(1,N), seq(N)),nrow=N))
t <- seq(10,20,length.out=N) + rnorm(N)
plot(X[,2],t,lwd=3)
(C <- t(X) %*% X)  # X^T X
t(X)
(C <- t(f) %*% f)  # X^T X
(f.pseudo <- solve(C) %*% t(f))  # (X^T X)^{-1} X^T
(f.pseudo %*% f) # és pseudo-inversa esquerra d'X
(w <- f.pseudo %*% l) # solució del problema
N <- 5
f <- matrix(c(rep(1,N), seq(N)),nrow=N)
l<-c(7.97,10.2,14.2,16.0,21.2)
plot(f,l)
plot(f[,2],l)
(C <- t(f) %*% f)  # X^T X
(f.pseudo <- solve(C) %*% t(f))  # (X^T X)^{-1} X^T
(f.pseudo %*% f) # és pseudo-inversa esquerra d'X
(w <- f.pseudo %*% l) # solució del problema
lines (f[,2], w[2,1]*f[,2]+w[1,1], type="l")
(s <- svd(f))
(s <- svd(f))
D <- diag(1/s$d)
(w <- s$v %*% D %*% t(s$u) %*% l)
library("Rcmndr")
library("Rcmdr")
install.packages("FactoMineR")
install.packages("rcmdcheck")
install.packages(c("BH", "bindr", "bindrcpp", "bit", "blob", "broom", "car", "caret", "chron", "CVST", "DBI", "ddalpha", "digest", "dplyr", "DRR", "e1071", "foreach", "ggfortify", "ggplot2", "glmnet", "glue", "gsubfn", "hms", "ipred", "iterators", "kernlab", "klaR", "lava", "lazyeval", "lme4", "lubridate", "ModelMetrics", "munsell", "pkgconfig", "plogr", "prodlim", "psych", "purrr", "quantreg", "randomForest", "Rcpp", "RcppEigen", "RcppRoll", "readxl", "recipes", "reshape2", "rlang", "Rmixmod", "robustbase", "RSQLite", "scales", "sfsmisc", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "timeDate", "tree", "TunePareto", "viridisLite", "withr"))
install.packages("Rcmdr")
install.packages("RcmdrMisc")
install.packages("car")
install.packages("rio")
install.packages("curl")
install.packages("curl")
install.packages("Rcmdr")
install.packages("RcmdrPlugin.FactoMineR")
Rcmdr
library(Rcmdr)
#generation of a normal distribution.
v1=rnorm(200, mean=0, sd=1)
summary(v1)
#Work with the data as a dataframe.
taula_v1=data.frame(x1=v1)
#Definition of the intervals, categories to be used.
taula_v1_cat=transform(taula_v1, cat = ifelse(x1 < -1,"-1",
ifelse(x1 < -0.5,"-0.5",
ifelse(x1 < 0,"0",
ifelse(x1 < 0.5,"0.5",
ifelse(x1 <1,"1","Inf"))))))
#Counting the amount of elements in each category “table” function.
taula_freq_v1=as.data.frame(with(taula_v1_cat, table(cat)))
taula_freq_v1=as.data.frame(with(taula_v1_cat, table(cat)))
library(Rcmdr)
barplot(taula_freq_v1)
View(taula_freq_v1)
View(taula_freq_v1)
View(taula_v1)
View(taula_v1_cat)
plot(taula_freq_v1)
View(taula_v1_cat)
histogram(taula_v1_cat)
hist(taula_v1_cat)
taula_v1_cat[1]
taula_v1_cat[2]
barplot(taula_v1_cat[2])
hist(taula_v1_cat[2])
hist(!taula_v1_cat[2])
hist(t(taula_v1_cat[2])
)
hist(t(taula_v1_cat[2]))
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
install.packages("Rcmdr")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
install.packages("Rcmdr")
install.packages("RcmdrMisc")
install.packages("RcmdrPlugin.FactoMineR")
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
install.packages("FactoMineR")
library(Rcmdr)
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
AnovaModel.1 <- aov(x1 ~ x2, data=data)
summary(AnovaModel.1)
Boxplot(x1~x2, data=data, id.method="y")
Norm_v1=rnorm(200, mean=0, sd=10)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=0.1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
AnovaModel.1 <- aov(x1 ~ x2, data=data)
summary(AnovaModel.1)
Boxplot(x1~x2, data=data, id.method="y")
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
AnovaModel.1 <- aov(x1 ~ x2, data=data)
summary(AnovaModel.1)
Boxplot(x1~x2, data=data, id.method="y")
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
AnovaModel.1 <- aov(x1 ~ x2, data=data)
summary(AnovaModel.1)
Boxplot(x1~x2, data=data, id.method="y")
View(AnovaModel.1)
View(AnovaModel.1)
library(Rcmdr)
Norm_v1=rnorm(200, mean=0, sd=1)
Norm_v2=rnorm(200, mean=10, sd=1)
Norm_v3=rnorm(200, mean=0, sd=1)
Norm_v1n=data.frame(x1=Norm_v1, x2="v1")
Norm_v2n=data.frame(x1=Norm_v2, x2="v2")
Norm_v3n=data.frame(x1=Norm_v3, x2="v3")
data=mergeRows(Norm_v1n, Norm_v2n, common.only=FALSE)
data=mergeRows(as.data.frame(data), Norm_v3n, common.only=FALSE)
AnovaModel.1 <- aov(x1 ~ x2, data=data)
summary(AnovaModel.1)
Boxplot(x1~x2, data=data, id.method="y")
View(AnovaModel.1)
View(myPCA)
View(data)
deca <- data(decathlon, package="FactoMineR")
View(decathlon)
deca <- data(decathlon, package="FactoMineR")
AnovaModel.1 <- aov(Points ~ Competition, data=deca)
deca <- data(decathlon, package="FactoMineR")
AnovaModel.2 <- aov(Points ~ Competition, data=deca)
AnovaModel.2 <- aov(deca$Points ~ deca$Competition, data=deca)
AnovaModel.2 <- aov(deca$Points ~ deca$Competition, data=data)
AnovaModel.2 <- aov(Points ~ Competition, data=data)
data <- data(decathlon, package="FactoMineR")
AnovaModel.2 <- aov(Points ~ Competition, data=data)
AnovaModel.2 <- aov(Javeline ~ Competition, data=data)
AnovaModel.2 <- aov(Javeline ~ Rank, data=data)
AnovaModel.2 <- aov(as.numeric(unlist(Javeline)) ~ Rank, data=data)
AnovaModel.2 <- aov(Javeline ~ Competition, data=data)
data$Competition
data
data$decathlon
data[decathlon]
data["decathlon"]
ls
data(decathlon, package="FactoMineR")
data
AnovaModel.2 <- aov(Javeline ~ Competition, data=decathlon)
decathlon
View(decathlon)
View(decathlon)
AnovaModel.2 <- aov(Javeline, Long.Jump ~ Competition, data=decathlon)
AnovaModel.2 <- aov(Javeline Long.Jump ~ Competition, data=decathlon)
AnovaModel.2 <- aov((Javeline,Long.Jump) ~ Competition, data=decathlon)
AnovaModel.2 <- aov((Javeline, Long.Jump) ~ Competition, data=decathlon)
AnovaModel.2 <- aov(c(Javeline, Long.Jump) ~ Competition, data=decathlon)
AnovaModel.2 <- aov(c(Javeline, Long.jump) ~ Competition, data=decathlon)
decathlon[-Competition]
decathlon[-'Competition']
decathlon['Competition']
AnovaModel.2 <- aov(decathlon-Competititon ~ Competition, data=decathlon)
AnovaModel.2 <- aov(decathlon-Competition ~ Competition, data=decathlon)
x=decathlon-decatlon['Competition']
data(decathlon, package="FactoMineR")
x=decathlon-decathlon['Competition']
x=decathlon.sub(decathlon['Competition'],axis=0)
x <- subset(decathlon, select= -c('Competition'))
x <- subset(decathlon, select= c(:13))
x <- subset(decathlon, select= c(1:13))
decathlon['Competition']
x
x <- subset(decathlon, select= c(1:12))
x
AnovaModel.2 <- aov(x ~ Competition, data=decathlon)
AnovaModel.2 <- aov(subset(decathlon, select= c(1:12)) ~ Competition, data=decathlon)
AnovaModel.2 <- aov(100m ~ Competition, data=decathlon)
AnovaModel.2 <- aov(decathlon[100m] ~ Competition, data=decathlon)
AnovaModel.2 <- aov(decathlon["100m"] ~ Competition, data=decathlon)
AnovaModel.2 <- aov("100m" ~ Competition, data=decathlon)
data(decathlon, package="FactoMineR")
for (name in colnames(decathlon)){
modname = paste("AnovaModel",name,sep=".")
assign(modname,aov(name ~ Competition, data=decathlon))
}
assign(modname,aov(decathlon[name] ~ Competition, data=decathlon))
install.packages("crypto", dependencies = TRUE)
library(neuralnet)
library(coinmarketcapr)
plot_top_5_currencies()
install.packages("neruralnet", dependencies = TRUE)
install.packages("neuralnet")
install.packages("coinmarketcapr")
library(treemap)
install.packages("treemap")
library(neuralnet)
library(coinmarketcapr)
plot_top_5_currencies()
market_today <- get_marketcap_ticker_all()
head(market_today[,1:8])
library(treemap)
df1 <- na.omit(market_today[,c('id','market_cap_usd')])
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
treemap(df1, index = 'formatted_market_cap', vSize = 'market_cap_usd', title = 'Cryptocurrency Market Cap', fontsize.labels=c(12, 8), palette='RdYlGn')
decathlon=data.frame(decathlon)
rand.order = sample(1:length(decathlon[,1]))
formula = X1500m ~ X400m + X100m + X110m.hurdle
lm(formula, data=decathlon)
plot(formula, data=decathlon)
data(decathlon, package="FactoMineR")
decathlon=data.frame(decathlon)
smp_size <- floor(0.75 * nrow(decathlon))
set.seed(123)
train_ind <- sample(seq_len(nrow(decathlon)), size = smp_size)
train <- decathlon[train_ind, ]
test <- decathlon[-train_ind, ]
formula = X1500m ~ X400m + X100m + X110m.hurdle
model = lm(formula, data=train)
plot(formula, data=train)
predict(model,test)
test$X1500m
View(test)
rownames(test)
formula = X1500m ~ X400m + X100m
model = lm(formula, data=train)
plot(formula, data=train)
predict(model,test)
predict(model,test,interval="prediction")
predict(model,test, interval="confidence")
library(neuralnet)
library(coinmarketcapr)
plot_top_5_currencies()
market_today <- get_marketcap_ticker_all()
head(market_today[,1:8])
library(treemap)
df1 <- na.omit(market_today[,c('id','market_cap_usd')])
df1$market_cap_usd <- as.numeric(df1$market_cap_usd)
df1$formatted_market_cap <-  paste0(df1$id,'\n','$',format(df1$market_cap_usd,big.mark = ',',scientific = F, trim = T))
treemap(df1, index = 'formatted_market_cap', vSize = 'market_cap_usd', title = 'Cryptocurrency Market Cap', fontsize.labels=c(12, 8), palette='RdYlGn')
getCoins()
crypto_history()
get_global_marketcap("EUR")
head(all_coins)
get_marketcap_ticker_all(currency = "EUR")
all_coins <- get_marketcap_ticker_all(currency = "EUR")
head(all_coins)
rownames(all_coins)
allcoins$names
all_coins$names
all_coins$name
all_coins <- get_marketcap_ticker_all(coin="Bitcoin")
setwd("/home/ripnotzz/Documentos/smde/Second_Assignment/smde-athletics/data")
read.csv("./final_marathon.csv")
df = read.csv("./final_marathon.csv")
df
df$Fitness
max(df$Fitness)
factors(df$Fitness)
(df$Fitness==1000)
x=0
if(df$Fitness==1000)x=x+1
x
sum(df$Fitness==1000)
sum(df$Fitness<1000 && df$Fitness>900)
sum(df$Fitness<1000 && df$Fitness>100)
sum(df$Fitness<1000 && df$Fitness>10)
sum(df$Fitness<1000 and df$Fitness>10)
sum(df$Fitness<1000 & df$Fitness>10)
sum(df$Fitness<1000 & df$Fitness>900)
sum(df$Fitness<100 & df$Fitness>0)
